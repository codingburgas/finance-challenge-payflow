#include "../Headers/EarningService.h"

bool EarningService::create(Earning newEarning) 
{
	std::string query = R"(
	INSERT INTO [Earnings]
			([UserId]
			,[Date]
			,[Type]
			,[Amount])
		VALUES (?,?,?,?)
	)";
	// I do not record the id because it is only generated by the database
	// By composing prepared queries, the database can compile the query only once, and then execute it repeatedly with different parameters
	nanodbc::statement create(conn);
	nanodbc::prepare(create, query);

	// Bind the parameters for the prepared statement
	create.bind(0, &newEarning.userId);
	create.bind(1, &newEarning.date);
	create.bind(2, newEarning.type.c_str());
	create.bind(3, &newEarning.amount);

	nanodbc::execute(create);

	return true;
}

std::vector<Earning> EarningService::readAll()
{
	std::string query = R"(
		SELECT [Id]
			,[UserId]
			,[Date]
			,[Type]
			,[Amount]
		FROM[Eernings]
	)";
	nanodbc::result queryResult = nanodbc::execute(conn, query);

	std::vector <Earning> earnings;
	while (queryResult.next()) {
		Earning earning;
		// Retrieves the id of the record from the "Id" column and assigns it to the id field of the earning object
		earning.id = queryResult.get<int>("Id");
		earning.userId = queryResult.get<int>("UserId");
		// The nanodbc::timestamp type is used so that the time value can be handled correctly
		earning.date = queryResult.get<nanodbc::timestamp>("Date");
		earning.type = queryResult.get<std::string>("Type");
		earning.amount = queryResult.get<double>("Amount");

		earnings.push_back(earning);
	}
	return earnings;
}

std::vector<Earning> EarningService::readByUserId(int userId, int year, int month)
{
	// SQL query to select earnings based on UserId, year, and month
	std::string query = R"(
		SELECT [Id]
              ,[UserId]
              ,[Date]
              ,[Type]
              ,[Amount]
        FROM [Earnings]
        WHERE [UserId] = ? AND
		YEAR([Date]) = ? AND MONTH([Date]) = ?
		ORDER BY [Date] DESC // Sort the results by the Date column in descending order
	)";

	nanodbc::statement select(conn);
	nanodbc::prepare(select, query);
	select.bind(0, &userId);
	select.bind(1, &year);
	select.bind(2, &month);

	nanodbc::result queryResult = nanodbc::execute(select);

	std::vector <Earning> earnings; // Vector to hold the resulting earnings
	while (queryResult.next()) {
		Earning earning;
		earning.id = queryResult.get<int>("Id");
		earning.userId = queryResult.get<int>("UserId");
		earning.date = queryResult.get<nanodbc::timestamp>("Date");
		earning.type = queryResult.get<std::string>("Type");
		earning.amount = queryResult.get<double>("Amount");

		earnings.push_back(earning);
	}
	return earnings;
}

Earning* EarningService::read(int id)
{
	std::string query = R"(
		SELECT [Id]
              ,[UserId]
              ,[Date]
              ,[Type]
              ,[Amount]
        FROM [Earnings]
        WHERE [Id] = ?
	)";

	nanodbc::statement select(conn);
	nanodbc::prepare(select, query);
	select.bind(0, &id);

	// The result dataset is assigned to queryResult
	// Retrieves the id of the record from the column and assigns it to the id field of the earning object
	nanodbc::result queryResult = nanodbc::execute(select);
	if (queryResult.next())
	{
		Earning* earning = new Earning();
		earning->id = queryResult.get<int>("Id");
		earning->userId = queryResult.get<int>("UserId");
		earning->date = queryResult.get<nanodbc::timestamp>("Date");
		earning->type = queryResult.get<std::string>("Type");
		earning->amount = queryResult.get<double>("Amount");

		return earning;
	}
	else
	{
		return nullptr;
	}
}

bool EarningService::update(int id, Earning updatedEarning)
{
	std::string query = R"(
        UPDATE [Earnings]
        SET [UserId] = ?
           ,[Date] = ?
           ,[Type] = ?
           ,[Amount] = ?
        WHERE [Id] = ?
    )";

	nanodbc::statement update(conn);
	nanodbc::prepare(update, query);

	update.bind(0, &updatedEarning.userId);
	update.bind(1, &updatedEarning.date);
	update.bind(2, updatedEarning.type.c_str());
	update.bind(3, &updatedEarning.amount);
	update.bind(4, &id);

	nanodbc::execute(update);
	return true;
}

bool EarningService::remove(int id)
{
	std::string query = R"(
        DELETE
        FROM [Earnings]
        WHERE [Id] = ?
    )";

	nanodbc::statement remove(conn);
	nanodbc::prepare(remove, query);
	remove.bind(0, &id);
	nanodbc::execute(remove);

	return true;
}

std::vector<Earning> EarningService::readFixedAmountByUser(int userId, int count)
{
	// SQL query to select a fixed number of earnings based on UserId
	std::string query = R"(
		SELECT [Id]
              ,[UserId]
              ,[Date]
              ,[Type]
              ,[Amount]
        FROM [Earnings]
        WHERE [UserId] = ?
		ORDER BY [Date]            
		OFFSET 0 ROWS   // In this case, 0 means that the result will start from the first row     
		FETCH NEXT ? ROWS ONLY;
	)";

	nanodbc::statement select(conn);
	nanodbc::prepare(select, query);
	select.bind(0, &userId);
	select.bind(1, &count);

	nanodbc::result queryResult = nanodbc::execute(select);

	std::vector <Earning> earnings;
	// Retrieves the id of the record from the column and assigns it to the id field of the earning object
	while (queryResult.next()) {
		Earning earning;
		earning.id = queryResult.get<int>("Id");
		earning.userId = queryResult.get<int>("UserId");
		earning.date = queryResult.get<nanodbc::timestamp>("Date");
		earning.type = queryResult.get<std::string>("Type");
		earning.amount = queryResult.get<double>("Amount");

		earnings.push_back(earning);
	}
	return earnings;
}